// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4980.PowerUp2018.subsystems;

import org.usfirst.frc4980.PowerUp2018.Robot;
import org.usfirst.frc4980.PowerUp2018.RobotMap;
import org.usfirst.frc4980.PowerUp2018.commands.*;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class driveSystem extends Subsystem implements PIDOutput {
	public boolean invert = false;
	PIDController controller;
	 double rotateToAngleRate;
	  static final double kP = 0.04;
	  static final double kI = 0.003;
	  static final double kD = 0.002;
	  static final double kF = 0.1;
	  static final double kToleranceDegrees = 5.0f;
	  double last_world_linear_accel_x;
	  double last_world_linear_accel_y;
	  final static double kCollisionThreshold_DeltaG = 0.6f;
	  
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
	private final WPI_TalonSRX frontLeftMotor = RobotMap.driveSystemfrontLeftMotor;
    private final WPI_TalonSRX frontRightMotor = RobotMap.driveSystemfrontRightMotor;
    private final WPI_TalonSRX backLeftMotor = RobotMap.driveSystembackLeftMotor;
    private final WPI_TalonSRX backRightMotor = RobotMap.driveSystembackRightMotor;
    double deadZone = 0.15; 
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public void setUpPIDController(){
    	controller = new PIDController(kP, kI, kD, kF, Robot.ahrs, this);
    	controller.setInputRange(-180.0f,  180.0f);
    	controller.setOutputRange(-0.5, 0.5);
    	controller.setAbsoluteTolerance(kToleranceDegrees);
    	controller.setContinuous(true);
    }
    public void enablePIDController(){
    	controller.enable();
    }
    public void disablePIDController(){
    	controller.disable();
    }
    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

       // setDefaultCommand(new cmdDriveXbox());
        setDefaultCommand(new cmdArcadeDriveXbox());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    }
    public void tankDriveXbox() {
    	double left = - Robot.oi.xboxDriver.getRawAxis(1);
    	double right = - Robot.oi.xboxDriver.getRawAxis(4);
    	double straightTolerance = 0.5;
    	if(Math.abs(left - right) <= straightTolerance){
    		left = right = (left + right) / 2.0;
    	}
    	if(invert){
    		// Invert signal
    		left = - left;
    		right = - right;
    	}
    	if(Math.abs(right)<deadZone){
     		 right = 0.0;
     	 }
     	 if(Math.abs(left)<deadZone) {
     		 left = 0.0;
     	 }
    	Robot.driveSystem.frontRightMotor.set(right);
    	frontLeftMotor.set(left);
    	frontRightMotor.set(right);
   	    backRightMotor.set(right);
   	    backLeftMotor.set(left);
 	}
    public void arcadeDriveXbox(){
    	double throttle = Robot.oi.xboxDriver.getRawAxis(1);
    	double turn = Robot.oi.xboxDriver.getRawAxis(4);
    	boolean squaredInputs = false;
    	double leftMotorSpeed = 0;
    	double rightMotorSpeed = 0;
    	double deadZone = 0.15;
    	double speedAdjustment = 1.0 - deadZone;
    	SmartDashboard.getNumber("D Pad", Robot.oi.xboxDriver2.getPOV());
//    	 UP          (0),
//         UP_RIGHT    (45),
//         RIGHT       (90),
//         DOWN_RIGHT  (135),
//         DOWN        (180),
//         DOWN_LEFT   (225),
//         LEFT        (270),
//         UP_LEFT     (315);
    	
    	if(Math.abs(throttle) < deadZone){
    		throttle = 0.0;
    	}////else{
    		//throttle = speedAdjustment * throttle;		
    	//}
    	if(Math.abs(turn) < deadZone){
    		turn = 0.0;
    	}////else{
    		//turn = speedAdjustment * turn;
    	//}
    	
    	
    	//throttle = (throttle-(Math.abs(throttle))/(throttle*deadZone))/speedAdjustment;
    	//throttle = 1.17 * throttle - 0.178;
    	// limit used if expected values are greater than 1 or less than -1
    	//throttle = limit(throttle);
    	// turn = limit(turn);
//    	if(squaredInputs){
//    		if(throttle >= deadZone){
//        		throttle = throttle * throttle;
//        	}else {
//        		throttle = -(throttle * throttle);
//        	}
//    		if(turn >=0.0){
//    			turn =turn * turn;
//    		}else{
//    			turn = -(turn * turn);
//    		}
//    	}
    	if(throttle > deadZone){
    		if(turn > deadZone){
    			leftMotorSpeed = throttle - turn;
    			rightMotorSpeed = Math.max(throttle, -turn);
    		}else{
    			leftMotorSpeed = throttle + turn;
    			rightMotorSpeed = throttle + turn;
    		}
    	} else {
    		if(turn > deadZone){
    			leftMotorSpeed = -Math.max(-throttle, turn);
    			rightMotorSpeed = throttle + turn;
    		}else {
    			leftMotorSpeed = throttle - turn;
    			rightMotorSpeed = -Math.max(-throttle, -turn);
    		}
    	}
    	SmartDashboard.putNumber("leftSpeed", leftMotorSpeed);
    	SmartDashboard.putNumber("rightSpeed", rightMotorSpeed);
    	frontLeftMotor.set(ControlMode.PercentOutput, -leftMotorSpeed);
    	frontRightMotor.set(ControlMode.PercentOutput, -rightMotorSpeed);
    	backLeftMotor.set(ControlMode.PercentOutput, -leftMotorSpeed);
    	backRightMotor.set(ControlMode.PercentOutput, -rightMotorSpeed);

    }
    public void rotate( double speed){
    	frontLeftMotor.set(ControlMode.PercentOutput, speed);
    	frontRightMotor.set(ControlMode.PercentOutput, -speed);
   	    backRightMotor.set(ControlMode.PercentOutput, -speed);
   	    backLeftMotor.set(ControlMode.PercentOutput, speed);
    	// TODO: Make robot turn in angle degrees
    }
    public void rotateToAngle(double angle){
    	rotate(rotateToAngleRate);
    	controller.setSetpoint(angle);
    }
    public boolean isOnTargetAngle(){
    	return controller.onTarget();
    }
    public void curve(double leftSpeed, double rightSpeed, double angle){
//    	if(minSpeed == 0.0 || maxSpeed == 0.0){
//    		return;
//    	}
    	//controller.setSetpoint(angle);
    	//double speed = rotateToAngleRate;
    	double speed = leftSpeed;
    	//SmartDashboard.putNumber("Rotate to Angle", speed);
    	//double adjustedSpeed = speed* (maxSpeed/minSpeed);
    	//SmartDashboard.putNumber("Adjusted Speed", speed);
    	double adjustedSpeed = rightSpeed;
    	
    		frontLeftMotor.set(leftSpeed);
    		backLeftMotor.set(leftSpeed);
        	frontRightMotor.set(rightSpeed);
        	backRightMotor.set(rightSpeed);
        	
    	
    }
  //Current Time = t
    //Start Value = b
    //Change in value = c
    //Duration = d
    public double easeIn(double t, double b, double c, double d) {
	   t = t/d;
	   return c*t*t+b;
   }
    
    public double easeOut(double t, double b, double c, double d){
    	t=t/d;
    	return -c*t*(t-2.0)+b;
    }
    public double easeInOut(double t, double b, double c, double d){
    	t/=d/2.0;
    	if(t<1){
    		return c/2.0*t*t+b;
    	}
    	return -c/2.0*((--t)*(t-2)-1)+b;
    }
	@Override
	public void pidWrite(double output) {
		// TODO Auto-generated method stub
		rotateToAngleRate = output;
	}
	public boolean pidOnTarget(){
		return controller.onTarget();
	}
	public void drive(double speed){
		frontLeftMotor.set(speed);
		backLeftMotor.set(speed);
		frontRightMotor.set(speed);
		backRightMotor.set(speed);
	}
	public boolean driveHasCollision(){
		 boolean collisionDetected = false;
		 
         
         double curr_world_linear_accel_x = Robot.ahrs.getWorldLinearAccelX();
         double currentJerkX = curr_world_linear_accel_x - last_world_linear_accel_x;
         last_world_linear_accel_x = curr_world_linear_accel_x;
         double curr_world_linear_accel_y = Robot.ahrs.getWorldLinearAccelY();
         double currentJerkY = curr_world_linear_accel_y - last_world_linear_accel_y;
         last_world_linear_accel_y = curr_world_linear_accel_y;
         currentJerkY = 0.0;
         if ( ( Math.abs(currentJerkX) > kCollisionThreshold_DeltaG ) || 
              ( Math.abs(currentJerkY) > kCollisionThreshold_DeltaG) ) {
             collisionDetected = true;
             SmartDashboard.putNumber("Collision Value X", Math.abs(currentJerkX));
             SmartDashboard.putNumber("Collision Value Y", Math.abs(currentJerkY));

         }
         SmartDashboard.putNumber("Collision Value XX", Math.abs(currentJerkX));
         SmartDashboard.putNumber("Collision Value YY", Math.abs(currentJerkY));
         SmartDashboard.putBoolean(  "CollisionDetected", collisionDetected);
		return collisionDetected;
	}

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
	public void stop(){
		frontLeftMotor.set(0);
		backLeftMotor.set(0);
		frontRightMotor.set(0);
		backRightMotor.set(0);
	}
}

